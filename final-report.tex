\documentclass[a4j]{jarticle}

\usepackage{url}

\textwidth=16cm

\oddsidemargin=0cm

\title{情報工学実験C ネットワークプログラミング}

\author{氏名:大西　隼也 \\学籍番号:09427510}

\date{出題日: 2017年12月12日\\提出日:2018年1月30日 \\締切日:2018年1月30日}

\begin{document}

\maketitle

\section{概要}
本実験では，基本的な通信方式であるTCP/IP，UDP/IPによるネットワークプログラミングについて学習する．
また，分散システムの基本的な形式であるクライアントサーバモデルの仕組みを学習する．
最終的に，クライアントサーバモデルに基づくプログラムを作成する．

\section{クライアント・サーバモデルの通信の仕組みについて}
クライアントサーバモデルとは，クライアントとサーバを分離して管理するソフトウェアモデルであり，今回の実験ではローカルの環境下で動作するプログラムを作成したが，ここでは，代表的なサーバモデルである，メールサーバやwebサーバとクライアントがインターネットを通じて通信する際の方法について概要を説明した後，実装したプログラムのソケットを用いた通信について述べる．

\subsection{インターネットでの通信の仕組み}

インターネット上のすべての計算機には，一意のIPアドレスが割り振られているため，IPアドレスを用いて計算機を特定することができる．しかし実際にIPアドレスを用いて通信を行おうとすると，例えば岡山大学のIPアドレス(150.46.30.130)など数字の羅列で人間が直感的に分かりにくいため，インターネット上のホスト名（www.okayama-u.ac.jp）とIPアドレスを対応させるシステム，DNS(Domain Name Service)が用いられている．

DNSもサーバの一種であり，ターミナル上でnslookupコマンドなどを用いて処理を依頼すると，ホスト名からIPアドレスに（正引き），IPアドレスからホスト名に（逆引き）の変換結果を返す．

また同時に複数の計算機と通信する際や通信相手計算機に複数のプログラムが存在する場合には，IPアドレスに加えて補助アドレスとしてポート番号を利用する．

ポート番号とは，0-65535の間で指定可能な数であり，サービスの種別を判断するために用いられる．
例えば，IPアドレス（150.46.30.130）とポート番号（80）は岡山大学のwebサーバを示す．

自作でプログラムを作成する際に注意したいのは，1023番までのポートはwell-knownポートと呼ばれ，主要なプロトコルで用いられる番号が決まっているため，それ以外の番号を利用する必要が有る．

\begin{itemize}
\item DNS(53)，HTTP(80)，POP3(110)など
\end{itemize}


\subsection{今回作成したクライアントサーバモデルでの通信}
以上述べてきたように，インターネットはTCP/IPという通信プロトコルを用いて通信を行っているが，実際にTCP/IPをプログラムから利用するには，プログラムとインターネットをつなぐ出入り口が必要になってくる．その出入り口となるのがソケットと呼ばれるものであり，TCP/IP通信はソケット通信と呼ばれることもある．

ソケットの最大の特徴として，ソケットを介してデータを送受信する際の要領が基本的にファイル入出力と同じであり，扱いやすいという利点がある．そのため単純なプロセス間通信では，通信相手プロセスとの間にソケットを生成し，そのソケット番号を通信に利用しながらソケットに対して送信や受信の命令を実行することでデータの送受信を実現している．


\section{名簿管理プログラムのクライアント・サーバプログラムの作成方針}

\subsection{名簿管理プログラムの仕様について}
基本的にはプログラミング演習で作成した名簿管理プログラムの入出力部分をsend関数やrecv関数を用いて書き換えを行い，サーバ，クライアント間で通信を行えるように実装し直す．

今回与えられた仕様として，名簿管理プログラム終了時，クライアントのみ終了し，サーバ側のプログラムは接続待機状態に戻り待つというものがあったので，通信部をwhile文で意図的に無限ループするような方針でプログラムを作成した．

\section{プログラム及び，その説明}

\subsection{TCP/IPのプロトコルの説明}

IPは，Internet Protocolの略称で，データグラムを転送するためのプロトコルとされている，アドレスとしてIPアドレスとポート番号を用いる．

TCPは，Transmissiomn Control Protocolの略称で，ストリーム転送サービスを提供しており，これにより，信頼性と複数回に分けて送り出したデータについても，順序を保証することが可能になっている．しかし，その分通信に時間がかかるというデメリットもある．

\subsection{名簿管理プログラムのコマンド一覧}

      \begin{tabular}{|l|l|l|}
        \hline
        コマンド& 意味& 備考\\
        \hline
        \%Q & 終了(Quit)& \\
        \hline
        \%C & 登録件数などの表示(Check)& \\
        \hline
        \%P n& 先頭からn件表示(Print)& n$=$0: 全件表示, n $<$ 0 後ろから　-n 件表示\\
        \hline
        \%R file& fileから読み込み(Read)& \\
        \hline
        \%W file & fileへ書き出し(Write)& \\
        \hline
        \%F word& wordを検索(Find)& 結果を\%Pと同じ形式で表示 \\
        \hline
        \%S n& データをn番目の項目で整列(Sort)& 表示はしない\\
        \hline
        \%D n& データをn件削除(Delete)& 仕様は後述する \\
        \hline
        \%A n& n番目にデータを登録(Add)& \\
        \hline
        \%B & 直前の状態に戻る(Back)& \%R,\%Aの使用後のみ\\
        \hline
        \%M & 各コマンドの仕様を表示(Manual)& \\
        \hline
      \end{tabular}
      
      \subsection{クライアントの処理の流れ}
ここでは，クライアントプログラムの主な処理の流れと, 今回使用したTCP/IPの関数について述べる．
\begin{enumerate}
\item 通信相手のIPアドレスを取得
	\begin{itemize}
	\item gethostbyname:IPアドレスを得る
	\end{itemize}
\item ソケットの作成
	\begin{itemize}
	\item socket:ソケットを作成する
	\end{itemize}
\item 接続の確立
	\begin{itemize}
	\item connect:コネクションを確立させる
	\end{itemize}
\item 要求メッセージを送信
	\begin{itemize}
	\item send:メッセージを送信する
	\end{itemize}
\item 応答メッセージを受信
	\begin{itemize}
	\item recv:メッセージを受信する
	\end{itemize}
\item 応答メッセージを処理
\item ソケットの削除
	\begin{itemize}
	\item close:ソケットを削除する
	\end{itemize}
\end{enumerate}

\subsection{サーバの処理の流れ}
サーバは要求メッセージの到着を常に待ち，要求メッセージが到着したら処理を行い，結果を送信する．
ここでは，サーバプログラムの主な処理の流れと，今回使用したTCP/IPの関数について述べる．
\begin{enumerate}
\item ソケットの作成
	\begin{itemize}
	\item socket:ソケットを作成する
	\end{itemize}
\item ソケットに名前をつける
	\begin{itemize}
	\item bind:ソケットに名前をつける
	\end{itemize}
\item 接続要求の受付を開始する
	\begin{itemize}
	\item listen:接続要求を待つ
	\end{itemize}
\item 接続要求を受け付ける
	\begin{itemize}
	\item accept:接続要求を受け付ける
	\end{itemize}
\item 要求メッセージを受信
	\begin{itemize}
	\item recv:メッセージを受信する
	\end{itemize}
\item 要求メッセージを処理
\item 応答メッセージを送信する
	\begin{itemize}
	\item send:メッセージを送信する
	\end{itemize}
\item 次の接続要求の受付を開始する
\end{enumerate}

\section{プログラムの使用法}
\subsection{クライアントプログラムの動作}
クライアント側のプログラムは起動後，ソケットを作成し，サーバ側との通信を確立した後，コマンドの入力待ちを行う．コマンドが入力されるとソケットを介してコマンドをサーバ側に送信し，処理結果を受け取り表示を行う．
\begin{verbatim}
oonishishunya-no-MacBook-Air:network oonishishunya$ ./meibomac-client localhost
クライアントの入力待ち
%C
登録件数は0件です．

クライアントの入力待ち
%R sample.csv
読み込みが完了しました．%C等で確認してください．

クライアントの入力待ち
%C
登録件数は2886件です．

クライアントの入力待ち
%Q
終了します。
\end{verbatim}

\subsection{サーバプログラムの動作}
サーバ側のプログラムは起動後，ソケットを作成し通信の準備が整ったらクライアントからの入力を待ち，\%Q以外のコマンドを受け取った際には処理を開始し結果をクライアントに返す．

\%Qコマンドを受け取った際には，処理を行わず通信待機状態へと戻る．
\begin{verbatim}
oonishishunya-no-MacBook-Air:network oonishishunya$ ./meibomac-server 
クライアントの入力待ち 
入力 %C
サーバの処理開始 
入力 after parse_line(): %C
処理終了

クライアントの入力待ち 
入力 %R sample.csv
サーバの処理開始 
入力 after parse_line(): %R sample.csv
処理終了

クライアントの入力待ち 
入力 %C
サーバの処理開始 
入力 after parse_line(): %C
処理終了

クライアントの入力待ち 
入力 %Q
処理終了
\end{verbatim}
\section{プログラムの作成過程に関する考察}

\subsection{工夫した点}
\subsubsection{ソケットの再送待機状態対策}
ソケットの特性上，一度ソケットをクローズすると，最初にクローズした側（今回の場合はクライアント側）は，再送待機状態(TIME\_WAIT)になる．この状態では，プログラム動作外で到着したパケットを破棄できるよう，数分間はCLOSED状態にならないので，他のソケットがそにポートを使用することができない．
対策法としては，最も単純なのがプログラムを起動するたびに使用するポートを変えるなどが考えられるが，今回は作成したソケットにSO\_REUSEADDRオプションを付加することで問題を解決した．

SO\_REUSEADDRオプションを付加することで，同じローカルアドレスにbindを行ってもエラーにならず処理を行うことができる．

\begin{verbatim}
  /* SO_REUSEADDR をつける*/

  int ret;
  ret = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR,(const char *)&yes, sizeof(yes));
  if(ret < 0){
    printf("Error : can't opt");
    return 0;
  }
  \end{verbatim}

\subsection{作成に苦労した点}

\subsubsection{\%Pコマンドの実装について}
\%Pコマンドに代表されるように，サーバ側のプログラムから複数件の結果が返される際，パケットの分割サイズを予測することができないため，\%Pコマンドの出力件数が一つずれたり，sendとrecvのデータ送受信の関係からコマンド実行後，意図しない出力が行われコアダンプを起こすなどの問題が頻発した．

そこで，\%Pコマンドを入力した際には，実際にプリント処理を行う，recv，sendのとは別に，何回プリント処理を行うか回数についてのみのデータの送受信を行うよう実装を行い，その後そのループ回数だけrecvを行うようクライアントプログラムを記述することで，問題を解決することができた．

\begin{verbatim}
    /*メッセージを受信する*/
    char kekka[MAX_LINE_LEN + 1];
    if((line[0]=='%' && line[1]=='P') || (line[0]=='%' && line[1]=='F')){
      bzero(&kekka, sizeof(kekka));
      recv(sockfd, kekka, sizeof(kekka), 0); //回数を受け取る
      int times;
      int l;
      times = atoi(kekka);
      for(l=0; l<times; l++){
	bzero(&kekka, sizeof(kekka));
	recv(sockfd, kekka, sizeof(kekka), 0);
	printf("%s\n", kekka);
      }
\end{verbatim}


\section{得られた結果に関する考察}
\subsection{recvとsendの対応付けに関する問題}
今回の実験は，クライアントサーバモデルを構成して以前作成したプログラムを動かすというものだったので，実際の名簿管理プログラムの速度的な性能や機能面などの考察はテーマに沿わないため，6章の作成過程に関する考察が中心となった．ここでは，プロセス間通信で想定外の動作を防ぐため特に注意し，実装に手間取ったrecvとsendの対応付けに関する問題について考察する．

自作の名簿管理プログラムのコマンドの中で，recvとsendの対応付けが一対一対応にならないものは，
\%P，\%F，\%A，\%Bの４つであった．

\%Pや\%Fの場合，問題になるのはプリント回数のみであるので，前述の考察で実装したように，プリント回数とプリント処理部をわけて通信を行うといった対応が可能だったが，\%Aや\%Bなど自作で機能拡張したコマンドなどはその関数の実装法などが一般的ではない場合もあるため，今回はクライアント側ですべて場合分けをしてコマンドごとにrecvとsendの回数を合わせにいったが，現実的ではないことがわかる．

インターネットやメールサーバなどユーザ数や同時アクセスの問題を考えると，個々の処理はその関数の中で完結するように実装を行い，ユーザインタフェースにあたる，クライアント部などのプログラムは単純に記述を行うことが，後々の仕様変更や保守の観点から見れば重要であると考えられる．

\subsection{考察に付随した感想}
自分の作成したプログラムでも１年前ともなると何を書いているか，関数がどう動いているかわからない部分が多く，コメントやレポートを丁寧に書いておくことの重要性を実感した．
また，先ほど考察したように，理想的には，名簿管理プログラムの内部で処理を完結させるような構造にしたかったが，当時プログラムが動けばさえすればいいと思ってコードを書いていた部分も多くあり，今回のように後から変更が加えづらい点でとても苦労したので，今後は保守性も意識してプログラムを作成しようと感じた．


\section{作成したプログラム}
今回，作成したプログラムのソースコードについて，名簿管理の処理を行うメインのプログラムに加え，その通信部分を担うクライアント，サーバプログラムの３つに分かれており，非常に膨大なページ数となるためgithubへのリンクと，プログラム名を記載することで割愛する．

\url{https://github.com/Shunya-Onishi/network}

\begin{itemize}
\item 名簿管理プログラム本体:meibo-prog.c
\item 名簿管理プログラムクライアント:meibo-client.c
\item 名簿管理プログラムサーバ:meibo-server.c
\end{itemize}

\end{document}



